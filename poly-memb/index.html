<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Poly-memb &mdash; poly_memb  documentation</title>
      <link rel="stylesheet" type="text/css" href="/poly-memb/_static/pygments.css" />
      <link rel="stylesheet" type="text/css" href="/poly-memb/_static/css/theme.css" />

  
    <link rel="canonical" href="https://aurelio-spadotto.github.io/poly-memb/index.html" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="/poly-memb/" id="documentation_options" src="/poly-memb/_static/documentation_options.js"></script>
        <script src="/poly-memb/_static/jquery.js"></script>
        <script src="/poly-memb/_static/underscore.js"></script>
        <script src="/poly-memb/_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="/poly-memb/_static/doctools.js"></script>
        <script src="/poly-memb/_static/sphinx_highlight.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="/poly-memb/_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="#" class="icon icon-home">
            poly_memb
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <!-- Local TOC -->
              <div class="local-toc"><ul>
<li><a class="reference internal" href="#">Poly-memb</a></li>
<li><a class="reference internal" href="#gallery">Gallery</a></li>
<li><a class="reference internal" href="#modules">Modules</a><ul>
<li><a class="reference internal" href="#module-mesh_manager">Module: mesh_manager</a><ul>
<li><a class="reference internal" href="#mesh_manager.adjacent_elements"><code class="docutils literal notranslate"><span class="pre">adjacent_elements()</span></code></a></li>
<li><a class="reference internal" href="#mesh_manager.agglomerate"><code class="docutils literal notranslate"><span class="pre">agglomerate()</span></code></a></li>
<li><a class="reference internal" href="#mesh_manager.agglomerate_2_elems"><code class="docutils literal notranslate"><span class="pre">agglomerate_2_elems()</span></code></a></li>
<li><a class="reference internal" href="#mesh_manager.break_mesh"><code class="docutils literal notranslate"><span class="pre">break_mesh()</span></code></a></li>
<li><a class="reference internal" href="#mesh_manager.calc_intersection"><code class="docutils literal notranslate"><span class="pre">calc_intersection()</span></code></a></li>
<li><a class="reference internal" href="#mesh_manager.calc_intersection_segments"><code class="docutils literal notranslate"><span class="pre">calc_intersection_segments()</span></code></a></li>
<li><a class="reference internal" href="#mesh_manager.calc_membrane_energy"><code class="docutils literal notranslate"><span class="pre">calc_membrane_energy()</span></code></a></li>
<li><a class="reference internal" href="#mesh_manager.calc_membrane_power"><code class="docutils literal notranslate"><span class="pre">calc_membrane_power()</span></code></a></li>
<li><a class="reference internal" href="#mesh_manager.calc_membrane_volume"><code class="docutils literal notranslate"><span class="pre">calc_membrane_volume()</span></code></a></li>
<li><a class="reference internal" href="#mesh_manager.calc_time_step"><code class="docutils literal notranslate"><span class="pre">calc_time_step()</span></code></a></li>
<li><a class="reference internal" href="#mesh_manager.check_and_add_new_points"><code class="docutils literal notranslate"><span class="pre">check_and_add_new_points()</span></code></a></li>
<li><a class="reference internal" href="#mesh_manager.check_if_in_triangle"><code class="docutils literal notranslate"><span class="pre">check_if_in_triangle()</span></code></a></li>
<li><a class="reference internal" href="#mesh_manager.check_if_present"><code class="docutils literal notranslate"><span class="pre">check_if_present()</span></code></a></li>
<li><a class="reference internal" href="#mesh_manager.compute_aspect_ratio"><code class="docutils literal notranslate"><span class="pre">compute_aspect_ratio()</span></code></a></li>
<li><a class="reference internal" href="#mesh_manager.cut_elem"><code class="docutils literal notranslate"><span class="pre">cut_elem()</span></code></a></li>
<li><a class="reference internal" href="#mesh_manager.disk_interface"><code class="docutils literal notranslate"><span class="pre">disk_interface</span></code></a><ul>
<li><a class="reference internal" href="#mesh_manager.disk_interface.edges"><code class="docutils literal notranslate"><span class="pre">disk_interface.edges</span></code></a></li>
<li><a class="reference internal" href="#mesh_manager.disk_interface.coords"><code class="docutils literal notranslate"><span class="pre">disk_interface.coords</span></code></a></li>
<li><a class="reference internal" href="#mesh_manager.disk_interface.velocity"><code class="docutils literal notranslate"><span class="pre">disk_interface.velocity</span></code></a></li>
<li><a class="reference internal" href="#mesh_manager.disk_interface.k_b"><code class="docutils literal notranslate"><span class="pre">disk_interface.k_b</span></code></a></li>
<li><a class="reference internal" href="#mesh_manager.disk_interface.k_str"><code class="docutils literal notranslate"><span class="pre">disk_interface.k_str</span></code></a></li>
<li><a class="reference internal" href="#mesh_manager.disk_interface.init_edge_length"><code class="docutils literal notranslate"><span class="pre">disk_interface.init_edge_length</span></code></a></li>
<li><a class="reference internal" href="#id0"><code class="docutils literal notranslate"><span class="pre">disk_interface.velocity</span></code></a></li>
<li><a class="reference internal" href="#mesh_manager.disk_interface.advect"><code class="docutils literal notranslate"><span class="pre">disk_interface.advect()</span></code></a></li>
<li><a class="reference internal" href="#mesh_manager.disk_interface.apply_LB"><code class="docutils literal notranslate"><span class="pre">disk_interface.apply_LB()</span></code></a></li>
<li><a class="reference internal" href="#mesh_manager.disk_interface.calc_F_bending"><code class="docutils literal notranslate"><span class="pre">disk_interface.calc_F_bending()</span></code></a></li>
<li><a class="reference internal" href="#mesh_manager.disk_interface.calc_F_stretching"><code class="docutils literal notranslate"><span class="pre">disk_interface.calc_F_stretching()</span></code></a></li>
<li><a class="reference internal" href="#mesh_manager.disk_interface.calc_curvature"><code class="docutils literal notranslate"><span class="pre">disk_interface.calc_curvature()</span></code></a></li>
<li><a class="reference internal" href="#mesh_manager.disk_interface.calc_edge_length"><code class="docutils literal notranslate"><span class="pre">disk_interface.calc_edge_length()</span></code></a></li>
<li><a class="reference internal" href="#mesh_manager.disk_interface.calc_nodal_forces"><code class="docutils literal notranslate"><span class="pre">disk_interface.calc_nodal_forces()</span></code></a></li>
<li><a class="reference internal" href="#mesh_manager.disk_interface.calc_normal"><code class="docutils literal notranslate"><span class="pre">disk_interface.calc_normal()</span></code></a></li>
<li><a class="reference internal" href="#mesh_manager.disk_interface.calc_t_gamma"><code class="docutils literal notranslate"><span class="pre">disk_interface.calc_t_gamma()</span></code></a></li>
<li><a class="reference internal" href="#mesh_manager.disk_interface.transfer_edge2node"><code class="docutils literal notranslate"><span class="pre">disk_interface.transfer_edge2node()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#mesh_manager.display_element"><code class="docutils literal notranslate"><span class="pre">display_element()</span></code></a></li>
<li><a class="reference internal" href="#mesh_manager.fill_side_mask"><code class="docutils literal notranslate"><span class="pre">fill_side_mask()</span></code></a></li>
<li><a class="reference internal" href="#mesh_manager.find_first_intersecting_edge"><code class="docutils literal notranslate"><span class="pre">find_first_intersecting_edge()</span></code></a></li>
<li><a class="reference internal" href="#mesh_manager.find_next_element"><code class="docutils literal notranslate"><span class="pre">find_next_element()</span></code></a></li>
<li><a class="reference internal" href="#mesh_manager.get_final_agglomerating"><code class="docutils literal notranslate"><span class="pre">get_final_agglomerating()</span></code></a></li>
<li><a class="reference internal" href="#mesh_manager.get_intersections"><code class="docutils literal notranslate"><span class="pre">get_intersections()</span></code></a></li>
<li><a class="reference internal" href="#mesh_manager.get_intface_data"><code class="docutils literal notranslate"><span class="pre">get_intface_data()</span></code></a></li>
<li><a class="reference internal" href="#mesh_manager.glob_idx"><code class="docutils literal notranslate"><span class="pre">glob_idx()</span></code></a></li>
<li><a class="reference internal" href="#mesh_manager.initialize_disk_interface"><code class="docutils literal notranslate"><span class="pre">initialize_disk_interface()</span></code></a></li>
<li><a class="reference internal" href="#mesh_manager.is_cut"><code class="docutils literal notranslate"><span class="pre">is_cut()</span></code></a></li>
<li><a class="reference internal" href="#mesh_manager.is_proper"><code class="docutils literal notranslate"><span class="pre">is_proper()</span></code></a></li>
<li><a class="reference internal" href="#mesh_manager.kron"><code class="docutils literal notranslate"><span class="pre">kron()</span></code></a></li>
<li><a class="reference internal" href="#mesh_manager.load_square_mesh"><code class="docutils literal notranslate"><span class="pre">load_square_mesh()</span></code></a></li>
<li><a class="reference internal" href="#mesh_manager.mark_bad_quality_elements"><code class="docutils literal notranslate"><span class="pre">mark_bad_quality_elements()</span></code></a></li>
<li><a class="reference internal" href="#mesh_manager.mesh2D"><code class="docutils literal notranslate"><span class="pre">mesh2D</span></code></a><ul>
<li><a class="reference internal" href="#mesh_manager.mesh2D.barycenter"><code class="docutils literal notranslate"><span class="pre">mesh2D.barycenter()</span></code></a></li>
<li><a class="reference internal" href="#mesh_manager.mesh2D.calc_surface"><code class="docutils literal notranslate"><span class="pre">mesh2D.calc_surface()</span></code></a></li>
<li><a class="reference internal" href="#mesh_manager.mesh2D.generate_edge2elem"><code class="docutils literal notranslate"><span class="pre">mesh2D.generate_edge2elem()</span></code></a></li>
<li><a class="reference internal" href="#mesh_manager.mesh2D.generate_elem2edge"><code class="docutils literal notranslate"><span class="pre">mesh2D.generate_elem2edge()</span></code></a></li>
<li><a class="reference internal" href="#mesh_manager.mesh2D.generate_elem2elem"><code class="docutils literal notranslate"><span class="pre">mesh2D.generate_elem2elem()</span></code></a></li>
<li><a class="reference internal" href="#mesh_manager.mesh2D.generate_intface_edges"><code class="docutils literal notranslate"><span class="pre">mesh2D.generate_intface_edges()</span></code></a></li>
<li><a class="reference internal" href="#mesh_manager.mesh2D.get_edge_length"><code class="docutils literal notranslate"><span class="pre">mesh2D.get_edge_length()</span></code></a></li>
<li><a class="reference internal" href="#mesh_manager.mesh2D.get_edge_normal"><code class="docutils literal notranslate"><span class="pre">mesh2D.get_edge_normal()</span></code></a></li>
<li><a class="reference internal" href="#mesh_manager.mesh2D.get_mesh_size"><code class="docutils literal notranslate"><span class="pre">mesh2D.get_mesh_size()</span></code></a></li>
<li><a class="reference internal" href="#mesh_manager.mesh2D.get_xE"><code class="docutils literal notranslate"><span class="pre">mesh2D.get_xE()</span></code></a></li>
<li><a class="reference internal" href="#mesh_manager.mesh2D.mark_bnd_edges"><code class="docutils literal notranslate"><span class="pre">mesh2D.mark_bnd_edges()</span></code></a></li>
<li><a class="reference internal" href="#mesh_manager.mesh2D.mark_bnd_points"><code class="docutils literal notranslate"><span class="pre">mesh2D.mark_bnd_points()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#mesh_manager.move_critical_points"><code class="docutils literal notranslate"><span class="pre">move_critical_points()</span></code></a></li>
<li><a class="reference internal" href="#mesh_manager.point_is_inside"><code class="docutils literal notranslate"><span class="pre">point_is_inside()</span></code></a></li>
<li><a class="reference internal" href="#mesh_manager.rotate_90_clockwise"><code class="docutils literal notranslate"><span class="pre">rotate_90_clockwise()</span></code></a></li>
<li><a class="reference internal" href="#mesh_manager.share_an_edge"><code class="docutils literal notranslate"><span class="pre">share_an_edge()</span></code></a></li>
<li><a class="reference internal" href="#mesh_manager.suppress_elements"><code class="docutils literal notranslate"><span class="pre">suppress_elements()</span></code></a></li>
<li><a class="reference internal" href="#mesh_manager.visualize_intface"><code class="docutils literal notranslate"><span class="pre">visualize_intface()</span></code></a></li>
<li><a class="reference internal" href="#mesh_manager.visualize_intface_nodal_vector"><code class="docutils literal notranslate"><span class="pre">visualize_intface_nodal_vector()</span></code></a></li>
<li><a class="reference internal" href="#mesh_manager.visualize_intface_vector"><code class="docutils literal notranslate"><span class="pre">visualize_intface_vector()</span></code></a></li>
<li><a class="reference internal" href="#mesh_manager.visualize_mesh"><code class="docutils literal notranslate"><span class="pre">visualize_mesh()</span></code></a></li>
<li><a class="reference internal" href="#mesh_manager.visualize_mesh_element_data"><code class="docutils literal notranslate"><span class="pre">visualize_mesh_element_data()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-HHO_stokes">Module: HHO_stokes</a><ul>
<li><a class="reference internal" href="#HHO_stokes.assemble_A"><code class="docutils literal notranslate"><span class="pre">assemble_A()</span></code></a></li>
<li><a class="reference internal" href="#HHO_stokes.assemble_B"><code class="docutils literal notranslate"><span class="pre">assemble_B()</span></code></a></li>
<li><a class="reference internal" href="#HHO_stokes.assemble_JP"><code class="docutils literal notranslate"><span class="pre">assemble_JP()</span></code></a></li>
<li><a class="reference internal" href="#HHO_stokes.assemble_STAB"><code class="docutils literal notranslate"><span class="pre">assemble_STAB()</span></code></a></li>
<li><a class="reference internal" href="#HHO_stokes.assemble_b_f"><code class="docutils literal notranslate"><span class="pre">assemble_b_f()</span></code></a></li>
<li><a class="reference internal" href="#HHO_stokes.assemble_b_gamma"><code class="docutils literal notranslate"><span class="pre">assemble_b_gamma()</span></code></a></li>
<li><a class="reference internal" href="#HHO_stokes.count_dof"><code class="docutils literal notranslate"><span class="pre">count_dof()</span></code></a></li>
<li><a class="reference internal" href="#HHO_stokes.dof_loc2glob"><code class="docutils literal notranslate"><span class="pre">dof_loc2glob()</span></code></a></li>
<li><a class="reference internal" href="#HHO_stokes.elem_velocity_energy_norm"><code class="docutils literal notranslate"><span class="pre">elem_velocity_energy_norm()</span></code></a></li>
<li><a class="reference internal" href="#HHO_stokes.get_disc_div"><code class="docutils literal notranslate"><span class="pre">get_disc_div()</span></code></a></li>
<li><a class="reference internal" href="#HHO_stokes.get_disc_div_from_localV"><code class="docutils literal notranslate"><span class="pre">get_disc_div_from_localV()</span></code></a></li>
<li><a class="reference internal" href="#HHO_stokes.get_edge_dofs"><code class="docutils literal notranslate"><span class="pre">get_edge_dofs()</span></code></a></li>
<li><a class="reference internal" href="#HHO_stokes.get_local_interpolation"><code class="docutils literal notranslate"><span class="pre">get_local_interpolation()</span></code></a></li>
<li><a class="reference internal" href="#HHO_stokes.get_local_polynomials"><code class="docutils literal notranslate"><span class="pre">get_local_polynomials()</span></code></a></li>
<li><a class="reference internal" href="#HHO_stokes.get_local_projections"><code class="docutils literal notranslate"><span class="pre">get_local_projections()</span></code></a></li>
<li><a class="reference internal" href="#HHO_stokes.get_local_velocities"><code class="docutils literal notranslate"><span class="pre">get_local_velocities()</span></code></a></li>
<li><a class="reference internal" href="#HHO_stokes.get_v_rec"><code class="docutils literal notranslate"><span class="pre">get_v_rec()</span></code></a></li>
<li><a class="reference internal" href="#HHO_stokes.get_v_rec_from_localV"><code class="docutils literal notranslate"><span class="pre">get_v_rec_from_localV()</span></code></a></li>
<li><a class="reference internal" href="#HHO_stokes.impose_bc"><code class="docutils literal notranslate"><span class="pre">impose_bc()</span></code></a></li>
<li><a class="reference internal" href="#HHO_stokes.interpolate_pressure"><code class="docutils literal notranslate"><span class="pre">interpolate_pressure()</span></code></a></li>
<li><a class="reference internal" href="#HHO_stokes.interpolate_solution"><code class="docutils literal notranslate"><span class="pre">interpolate_solution()</span></code></a></li>
<li><a class="reference internal" href="#HHO_stokes.interpolate_velocity"><code class="docutils literal notranslate"><span class="pre">interpolate_velocity()</span></code></a></li>
<li><a class="reference internal" href="#HHO_stokes.loc_dof_description"><code class="docutils literal notranslate"><span class="pre">loc_dof_description()</span></code></a></li>
<li><a class="reference internal" href="#HHO_stokes.local_contribution_aT"><code class="docutils literal notranslate"><span class="pre">local_contribution_aT()</span></code></a></li>
<li><a class="reference internal" href="#HHO_stokes.local_contribution_bT"><code class="docutils literal notranslate"><span class="pre">local_contribution_bT()</span></code></a></li>
<li><a class="reference internal" href="#HHO_stokes.local_contribution_fT"><code class="docutils literal notranslate"><span class="pre">local_contribution_fT()</span></code></a></li>
<li><a class="reference internal" href="#HHO_stokes.local_contribution_sT"><code class="docutils literal notranslate"><span class="pre">local_contribution_sT()</span></code></a></li>
<li><a class="reference internal" href="#HHO_stokes.p_v_error"><code class="docutils literal notranslate"><span class="pre">p_v_error()</span></code></a></li>
<li><a class="reference internal" href="#HHO_stokes.pressure_L2_norm"><code class="docutils literal notranslate"><span class="pre">pressure_L2_norm()</span></code></a></li>
<li><a class="reference internal" href="#HHO_stokes.solve_stokes"><code class="docutils literal notranslate"><span class="pre">solve_stokes()</span></code></a></li>
<li><a class="reference internal" href="#HHO_stokes.transfer_velocity_and_advect_interface"><code class="docutils literal notranslate"><span class="pre">transfer_velocity_and_advect_interface()</span></code></a></li>
<li><a class="reference internal" href="#HHO_stokes.velocity_energy_norm"><code class="docutils literal notranslate"><span class="pre">velocity_energy_norm()</span></code></a></li>
<li><a class="reference internal" href="#HHO_stokes.visualize_solution"><code class="docutils literal notranslate"><span class="pre">visualize_solution()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-DDR_intface">Module: DDR_intface</a><ul>
<li><a class="reference internal" href="#DDR_intface.assemble_G"><code class="docutils literal notranslate"><span class="pre">assemble_G()</span></code></a></li>
<li><a class="reference internal" href="#DDR_intface.assemble_M_gamma"><code class="docutils literal notranslate"><span class="pre">assemble_M_gamma()</span></code></a></li>
<li><a class="reference internal" href="#DDR_intface.assemble_N_gamma"><code class="docutils literal notranslate"><span class="pre">assemble_N_gamma()</span></code></a></li>
<li><a class="reference internal" href="#DDR_intface.assemble_S"><code class="docutils literal notranslate"><span class="pre">assemble_S()</span></code></a></li>
<li><a class="reference internal" href="#DDR_intface.assemble_b_J"><code class="docutils literal notranslate"><span class="pre">assemble_b_J()</span></code></a></li>
<li><a class="reference internal" href="#DDR_intface.calc_L0_error"><code class="docutils literal notranslate"><span class="pre">calc_L0_error()</span></code></a></li>
<li><a class="reference internal" href="#DDR_intface.calc_L2_error"><code class="docutils literal notranslate"><span class="pre">calc_L2_error()</span></code></a></li>
<li><a class="reference internal" href="#DDR_intface.calc_energy_error"><code class="docutils literal notranslate"><span class="pre">calc_energy_error()</span></code></a></li>
<li><a class="reference internal" href="#DDR_intface.calc_r2_prod_integ"><code class="docutils literal notranslate"><span class="pre">calc_r2_prod_integ()</span></code></a></li>
<li><a class="reference internal" href="#DDR_intface.calc_t_maxwell"><code class="docutils literal notranslate"><span class="pre">calc_t_maxwell()</span></code></a></li>
<li><a class="reference internal" href="#DDR_intface.count_dof"><code class="docutils literal notranslate"><span class="pre">count_dof()</span></code></a></li>
<li><a class="reference internal" href="#DDR_intface.disc_grad"><code class="docutils literal notranslate"><span class="pre">disc_grad()</span></code></a></li>
<li><a class="reference internal" href="#DDR_intface.glob_idx"><code class="docutils literal notranslate"><span class="pre">glob_idx()</span></code></a></li>
<li><a class="reference internal" href="#DDR_intface.impose_bc"><code class="docutils literal notranslate"><span class="pre">impose_bc()</span></code></a></li>
<li><a class="reference internal" href="#DDR_intface.p1_rec_matrix"><code class="docutils literal notranslate"><span class="pre">p1_rec_matrix()</span></code></a></li>
<li><a class="reference internal" href="#DDR_intface.pretty_visualize"><code class="docutils literal notranslate"><span class="pre">pretty_visualize()</span></code></a></li>
<li><a class="reference internal" href="#DDR_intface.pretty_visualize_gradient"><code class="docutils literal notranslate"><span class="pre">pretty_visualize_gradient()</span></code></a></li>
<li><a class="reference internal" href="#DDR_intface.reference_solution"><code class="docutils literal notranslate"><span class="pre">reference_solution()</span></code></a></li>
<li><a class="reference internal" href="#DDR_intface.solve"><code class="docutils literal notranslate"><span class="pre">solve()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#bibliography">Bibliography</a></li>
<li><a class="reference internal" href="#indices-and-tables">Indices and tables</a></li>
</ul>
</div>
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="#">poly_memb</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="#" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Poly-memb</li>
      <li class="wy-breadcrumbs-aside">
            <a href="/poly-memb/_sources/index.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="poly-memb">
<h1>Poly-memb<a class="headerlink" href="#poly-memb" title="Permalink to this heading"></a></h1>
<p>poly-memb is a Python library implementing a 2D simulator of dynamics of membranes subject to electric fields.
The module ‘mesh_manager’ provides functions to generate polytopal meshes by cutting and agglomerating
background meshes intersected by moving interfaces.
The module ‘solvers’ provides functions to implement polygonal numerical schemes.
The simulator is based on a Hybrid High Order scheme <span id="id1">[<a class="reference internal" href="#id235" title="D. A. Di Pietro and J. Droniou. The Hybrid High-Order method for polytopal meshes. Number 19 in Modeling, Simulation and Application. Springer International Publishing, 2020. doi:10.1007/978-3-030-37203-3.">1</a>]</span> to solve flow variables
and a Discrete De Rham <span id="id2">[<a class="reference internal" href="#id237" title="Daniele A. Di Pietro and Jérôme Droniou. An arbitrary-order discrete de Rham complex on polyhedral meshes: Exactness, Poincaré inequalities, and consistency. Found. Comput. Math., 23:85–164, 2023. doi:10.1007/s10208-021-09542-8.">2</a>]</span> scheme to solve for electric variables.</p>
</section>
<section id="gallery">
<h1>Gallery<a class="headerlink" href="#gallery" title="Permalink to this heading"></a></h1>
<figure class="align-center align-default" id="id473">
<a class="reference internal image-reference" href="/poly-memb/_images/agglomeration_demo.png"><img alt="Output 1" src="/poly-memb/_images/agglomeration_demo.png" style="width: 800px;" /></a>
<figcaption>
<p><span class="caption-text">Example of supported mesh, before and after agglomeration. The polygonal interface cuts
originally simplicial elements to originate conformal polygonal subelements.
The cut procedure is reiterated after movement of the membrane.</span><a class="headerlink" href="#id473" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<figure class="align-center align-default" id="id474">
<a class="reference internal image-reference" href="/poly-memb/_images/electric_solver_demo.png"><img alt="Output 2" src="/poly-memb/_images/electric_solver_demo.png" style="width: 800px;" /></a>
<figcaption>
<p><span class="caption-text">Electrostatic potential and electric field resulting from the DDR method.
The conformal setting allows for seamless treatment of interface conditions.</span><a class="headerlink" href="#id474" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<figure class="align-center align-default" id="id475">
<a class="reference internal image-reference" href="/poly-memb/_images/solver_flow_demo.png"><img alt="Output 3" src="/poly-memb/_images/solver_flow_demo.png" style="width: 800px;" /></a>
<figcaption>
<p><span class="caption-text">A HHO solver is used to determine the membrane velocity. Interface edges are embedded as mesh edges.</span><a class="headerlink" href="#id475" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<div class="toctree-wrapper compound">
</div>
</section>
<section id="modules">
<h1>Modules<a class="headerlink" href="#modules" title="Permalink to this heading"></a></h1>
<section id="module-mesh_manager">
<span id="module-mesh-manager"></span><h2>Module: mesh_manager<a class="headerlink" href="#module-mesh_manager" title="Permalink to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="mesh_manager.adjacent_elements">
<span class="sig-prename descclassname"><span class="pre">mesh_manager.</span></span><span class="sig-name descname"><span class="pre">adjacent_elements</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">elem2node</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cut_iel</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">intsec_points</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mesh_manager.adjacent_elements" title="Permalink to this definition"></a></dt>
<dd><p>List of adjacent elements of a element to cut</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>elem2node</strong> (<em>type</em><em> of </em><em>mesh2D.elem2node</em>) – element to node connectivity</p></li>
<li><p><strong>cut_iel</strong> (<em>int</em>) – element index of cut element</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>adjacent elements’ indexes</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mesh_manager.agglomerate">
<span class="sig-prename descclassname"><span class="pre">mesh_manager.</span></span><span class="sig-name descname"><span class="pre">agglomerate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ref_mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cryt_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cryt_skewness</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mesh_manager.agglomerate" title="Permalink to this definition"></a></dt>
<dd><p>Agglomerate bad quality elements</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mesh</strong> (<a class="reference internal" href="#mesh_manager.mesh2D" title="mesh_manager.mesh2D"><em>mesh2D</em></a>) – mesh</p></li>
<li><p><strong>ref_mesh</strong> (<a class="reference internal" href="#mesh_manager.mesh2D" title="mesh_manager.mesh2D"><em>mesh2D</em></a>) – reference uncut mesh</p></li>
<li><p><strong>cryt_size</strong> (<em>float</em>) – minimal accepted relative size for elements</p></li>
<li><p><strong>cryt_skewness</strong> (<em>float</em>) – maximal accepted skewness for elements</p></li>
<li><p><strong>verbose</strong> (<em>boolean</em>) – display partial outputs</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>mesh2D</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mesh_manager.agglomerate_2_elems">
<span class="sig-prename descclassname"><span class="pre">mesh_manager.</span></span><span class="sig-name descname"><span class="pre">agglomerate_2_elems</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">elem_agglomerating</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">elem_to_agglomerate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">intface_data_agglomerating</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">intface_data_to_agglomerate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mesh_manager.agglomerate_2_elems" title="Permalink to this definition"></a></dt>
<dd><p>Agglomerate 2 elements provided as lists of points.
Currently, agglomerations are done under the hypothesis that
the elements share only 1 edge (may not always be the case)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>elem_agglomerating</strong> (<em>list</em>) – agglomerating element as list of point indexes. Example: [0, 1, 2]</p></li>
<li><p><strong>elem_to_agglomerate</strong> (<em>list</em>) – element to agglomerate</p></li>
<li><p><strong>intface_data_agglomerating</strong> (<em>list</em>) – interface data for agglomerating element; formatted as [cut_idx, no_edges, first_ie]. Example: [[], [], []]</p></li>
<li><p><strong>intface_data_to_agglomerate</strong> (<em>list</em><em>(</em><em>list</em>) – interface data for element to agglomerate</p></li>
<li><p><strong>verbose</strong> (<em>boolean</em>) – whether to display internal outputs</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>[agglomerate element, intface_data_of_agglomerate_element].</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mesh_manager.break_mesh">
<span class="sig-prename descclassname"><span class="pre">mesh_manager.</span></span><span class="sig-name descname"><span class="pre">break_mesh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">intface</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mesh_manager.break_mesh" title="Permalink to this definition"></a></dt>
<dd><p>Breaks mesh along interface
Remark: treat also case of element with multiple cuts</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mesh</strong> (<a class="reference internal" href="#mesh_manager.mesh2D" title="mesh_manager.mesh2D"><em>mesh2D</em></a>) – mesh to break</p></li>
<li><p><strong>intface</strong> (<a class="reference internal" href="#mesh_manager.disk_interface" title="mesh_manager.disk_interface"><em>disk_interface</em></a>) – interface along which to cut</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>cut mesh</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#mesh_manager.mesh2D" title="mesh_manager.mesh2D">mesh2D</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mesh_manager.calc_intersection">
<span class="sig-prename descclassname"><span class="pre">mesh_manager.</span></span><span class="sig-name descname"><span class="pre">calc_intersection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rho</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mesh_manager.calc_intersection" title="Permalink to this definition"></a></dt>
<dd><p>Check if segment on a plane intersects with ball of radius rho.</p>
<p>Parameters:
- x1: x coord of point1
- x2: x coord of point2
- y1: y coord of point1
- y2: y coord of point2
- rho: disk radius</p>
<p>Returns:
- True/False
- intersection position</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mesh_manager.calc_intersection_segments">
<span class="sig-prename descclassname"><span class="pre">mesh_manager.</span></span><span class="sig-name descname"><span class="pre">calc_intersection_segments</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">B1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">A2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">B2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mesh_manager.calc_intersection_segments" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mesh_manager.calc_membrane_energy">
<span class="sig-prename descclassname"><span class="pre">mesh_manager.</span></span><span class="sig-name descname"><span class="pre">calc_membrane_energy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">intface</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mesh_manager.calc_membrane_energy" title="Permalink to this definition"></a></dt>
<dd><p>Calculates total energy of the membrane</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mesh_manager.calc_membrane_power">
<span class="sig-prename descclassname"><span class="pre">mesh_manager.</span></span><span class="sig-name descname"><span class="pre">calc_membrane_power</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">intface</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mesh_manager.calc_membrane_power" title="Permalink to this definition"></a></dt>
<dd><p>Calculates power acting on the membrane</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mesh_manager.calc_membrane_volume">
<span class="sig-prename descclassname"><span class="pre">mesh_manager.</span></span><span class="sig-name descname"><span class="pre">calc_membrane_volume</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">intface</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mesh_manager.calc_membrane_volume" title="Permalink to this definition"></a></dt>
<dd><p>Calculates  volume of surface</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>u</strong> (<em>np.array</em>) – P^1(Gamma_h)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mesh_manager.calc_time_step">
<span class="sig-prename descclassname"><span class="pre">mesh_manager.</span></span><span class="sig-name descname"><span class="pre">calc_time_step</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">intface</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eta</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mesh_manager.calc_time_step" title="Permalink to this definition"></a></dt>
<dd><p>Calculates time step such that energy increase is controlled
:type intface: 
:param intface: interface
:type intface: mema.disk_intface
:type eta: 
:param eta: user-dependent parameter
:type eta: float</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mesh_manager.check_and_add_new_points">
<span class="sig-prename descclassname"><span class="pre">mesh_manager.</span></span><span class="sig-name descname"><span class="pre">check_and_add_new_points</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">new_coords</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">new_points</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mesh_manager.check_and_add_new_points" title="Permalink to this definition"></a></dt>
<dd><p>Add a bunch of new points to a list of points if not already there
and provide indexes on the new entries</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>new_coords</strong> (<em>list</em><em>(</em><em>np.array</em><em>)</em>) – list of points</p></li>
<li><p><strong>new_points</strong> (<em>list</em><em>(</em><em>np.arra</em><em>)</em>) – points to add</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mesh_manager.check_if_in_triangle">
<span class="sig-prename descclassname"><span class="pre">mesh_manager.</span></span><span class="sig-name descname"><span class="pre">check_if_in_triangle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mesh_manager.check_if_in_triangle" title="Permalink to this definition"></a></dt>
<dd><p>Check if point q is inside the triangle formed by points p1, p2, and p3.</p>
<p>Parameters:
p1, p2, p3: Tuples representing the vertices of the triangle (x, y).
q: Tuple representing the point to check (x, y).</p>
<p>Returns:
bool: True if q is inside the triangle, False otherwise.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mesh_manager.check_if_present">
<span class="sig-prename descclassname"><span class="pre">mesh_manager.</span></span><span class="sig-name descname"><span class="pre">check_if_present</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node_coords</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mesh_manager.check_if_present" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mesh_manager.compute_aspect_ratio">
<span class="sig-prename descclassname"><span class="pre">mesh_manager.</span></span><span class="sig-name descname"><span class="pre">compute_aspect_ratio</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">polygon_coords</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mesh_manager.compute_aspect_ratio" title="Permalink to this definition"></a></dt>
<dd><p>Compute the robust aspect ratio of a polygon using PCA
(bounding box in the system of principal axes)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mesh_manager.cut_elem">
<span class="sig-prename descclassname"><span class="pre">mesh_manager.</span></span><span class="sig-name descname"><span class="pre">cut_elem</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coords</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">elem</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">intface</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ied</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mesh_manager.cut_elem" title="Permalink to this definition"></a></dt>
<dd><p>Function to cut an element, and enrich a list of mesh points</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>coords</strong> (<em>list</em><em>(</em><em>np.array</em><em>)</em>) – list of points</p></li>
<li><p><strong>elem</strong> (<em>list</em><em>(</em><em>int</em><em>)</em>) – list of node idxs of the element</p></li>
<li><p><strong>intface</strong> (<a class="reference internal" href="#mesh_manager.disk_interface" title="mesh_manager.disk_interface"><em>disk_interface</em></a>) – interface</p></li>
<li><p><strong>ied</strong> (<em>int</em>) – entering intface edge</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>enriched list points
list (int): list of intface edges of the cut
list(int): first child element
list(nt): second child element
int: last edge of the cut (and first of the next)</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list (np.array)</p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mesh_manager.disk_interface">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mesh_manager.</span></span><span class="sig-name descname"><span class="pre">disk_interface</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">edges</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coords</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k_b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k_str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init_edge_length</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">velocity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mesh_manager.disk_interface" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Interface class; implemented as chain of edges</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="mesh_manager.disk_interface.edges">
<span class="sig-name descname"><span class="pre">edges</span></span><a class="headerlink" href="#mesh_manager.disk_interface.edges" title="Permalink to this definition"></a></dt>
<dd><p>edge to node connectivity</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>list(list(int))</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mesh_manager.disk_interface.coords">
<span class="sig-name descname"><span class="pre">coords</span></span><a class="headerlink" href="#mesh_manager.disk_interface.coords" title="Permalink to this definition"></a></dt>
<dd><p>node coordinates</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>list(np.array)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mesh_manager.disk_interface.velocity">
<span class="sig-name descname"><span class="pre">velocity</span></span><a class="headerlink" href="#mesh_manager.disk_interface.velocity" title="Permalink to this definition"></a></dt>
<dd><p>edge velocity</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>list(np.array)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mesh_manager.disk_interface.k_b">
<span class="sig-name descname"><span class="pre">k_b</span></span><a class="headerlink" href="#mesh_manager.disk_interface.k_b" title="Permalink to this definition"></a></dt>
<dd><p>bending modulus</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mesh_manager.disk_interface.k_str">
<span class="sig-name descname"><span class="pre">k_str</span></span><a class="headerlink" href="#mesh_manager.disk_interface.k_str" title="Permalink to this definition"></a></dt>
<dd><p>stretching modulus</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mesh_manager.disk_interface.init_edge_length">
<span class="sig-name descname"><span class="pre">init_edge_length</span></span><a class="headerlink" href="#mesh_manager.disk_interface.init_edge_length" title="Permalink to this definition"></a></dt>
<dd><p>reference edge length</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>list(float)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="id0">
<span class="sig-name descname"><span class="pre">velocity</span></span><a class="headerlink" href="#id0" title="Permalink to this definition"></a></dt>
<dd><p>edge velocity (0 if not assigned)</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>list(np.array)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mesh_manager.disk_interface.advect">
<span class="sig-name descname"><span class="pre">advect</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">delta_t</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mesh_manager.disk_interface.advect" title="Permalink to this definition"></a></dt>
<dd><p>Advect interface using velocity</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>delta_t</strong> (<em>float</em>) – time step</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>moved interface</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>disk_intface</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mesh_manager.disk_interface.apply_LB">
<span class="sig-name descname"><span class="pre">apply_LB</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mesh_manager.disk_interface.apply_LB" title="Permalink to this definition"></a></dt>
<dd><p>Applies discrete Laplace-Beltrami Operator</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>data</strong> (<em>list</em>) – node-valued field</p>
</dd>
</dl>
<dl class="simple">
<dt>Returns</dt><dd><p>list: node_valued curve Laplacian (LB) of data</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mesh_manager.disk_interface.calc_F_bending">
<span class="sig-name descname"><span class="pre">calc_F_bending</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mesh_manager.disk_interface.calc_F_bending" title="Permalink to this definition"></a></dt>
<dd><p>Calculates nodal force $F_{bending}$;</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>nodal force (vector)</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>list(np.array)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mesh_manager.disk_interface.calc_F_stretching">
<span class="sig-name descname"><span class="pre">calc_F_stretching</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mesh_manager.disk_interface.calc_F_stretching" title="Permalink to this definition"></a></dt>
<dd><p>Calculates nodal force $F_{stretching}$;
Hooke’s elastic law</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>nodal force (vector)</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>list(np.array)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mesh_manager.disk_interface.calc_curvature">
<span class="sig-name descname"><span class="pre">calc_curvature</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mesh_manager.disk_interface.calc_curvature" title="Permalink to this definition"></a></dt>
<dd><p>Calculate node curvature</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>node curvature</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>list(float)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mesh_manager.disk_interface.calc_edge_length">
<span class="sig-name descname"><span class="pre">calc_edge_length</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mesh_manager.disk_interface.calc_edge_length" title="Permalink to this definition"></a></dt>
<dd><p>Calculates length of the edges</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>list of edge lengths</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>list(float)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mesh_manager.disk_interface.calc_nodal_forces">
<span class="sig-name descname"><span class="pre">calc_nodal_forces</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mesh_manager.disk_interface.calc_nodal_forces" title="Permalink to this definition"></a></dt>
<dd><p>Calculates nodal forces;
$F = F_{bending} + F_{stretching}$</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>edge_wise constant surface tension (vector)</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>list(np.array)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mesh_manager.disk_interface.calc_normal">
<span class="sig-name descname"><span class="pre">calc_normal</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mesh_manager.disk_interface.calc_normal" title="Permalink to this definition"></a></dt>
<dd><p>Calculate edge normal</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mesh_manager.disk_interface.calc_t_gamma">
<span class="sig-name descname"><span class="pre">calc_t_gamma</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mesh_manager.disk_interface.calc_t_gamma" title="Permalink to this definition"></a></dt>
<dd><p>Calculates surface tension $t_Gamma$ by calculating nodal
forces and transferring onto edges with correct scaling</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>edge_wise constant surface tension (vector)</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>list(np.array)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mesh_manager.disk_interface.transfer_edge2node">
<span class="sig-name descname"><span class="pre">transfer_edge2node</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mesh_manager.disk_interface.transfer_edge2node" title="Permalink to this definition"></a></dt>
<dd><p>Tranfers an interface property from edges to nodes
or viceversa applying average</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>data</strong> (<em>list</em>) – a data defined as a list over edges or nodes</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>ransferred data</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mesh_manager.display_element">
<span class="sig-prename descclassname"><span class="pre">mesh_manager.</span></span><span class="sig-name descname"><span class="pre">display_element</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">elem</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">color</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'black'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">display_nodes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mesh_manager.display_element" title="Permalink to this definition"></a></dt>
<dd><p>Display single element
:type mesh: 
:param mesh: mesh
:type mesh: mesh2D
:type elem: 
:param elem: element (list of points)
:type elem: list(int)
:type ax: 
:param ax: axes
:type color: 
:param color: color of edges
:type display_nodes: 
:param display_nodes: show indexes of nodes (both local and global)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mesh_manager.fill_side_mask">
<span class="sig-prename descclassname"><span class="pre">mesh_manager.</span></span><span class="sig-name descname"><span class="pre">fill_side_mask</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mesh_manager.fill_side_mask" title="Permalink to this definition"></a></dt>
<dd><p>Complete side mask by extrapolating value at interface up to the border
(uses dofs associated to nodes as in ddrin)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mesh</strong> (<a class="reference internal" href="#mesh_manager.mesh2D" title="mesh_manager.mesh2D"><em>mesh2D</em></a>) – mesh</p></li>
<li><p><strong>no_elems_init</strong> (<em>int</em>) – original numer of element</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mesh_manager.find_first_intersecting_edge">
<span class="sig-prename descclassname"><span class="pre">mesh_manager.</span></span><span class="sig-name descname"><span class="pre">find_first_intersecting_edge</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">intface</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mesh_manager.find_first_intersecting_edge" title="Permalink to this definition"></a></dt>
<dd><p>Find the first interface edge crossing a mesh edge
and getting inside the element</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mesh</strong> (<em>2D_mesh</em>) – mesh</p></li>
<li><p><strong>intface</strong> (<em>disk_intface</em>) – intface</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>edge index</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mesh_manager.find_next_element">
<span class="sig-prename descclassname"><span class="pre">mesh_manager.</span></span><span class="sig-name descname"><span class="pre">find_next_element</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">elem2node</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coords</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cut_elems</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">intface</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ied</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cut_iel</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">intsec_points</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mesh_manager.find_next_element" title="Permalink to this definition"></a></dt>
<dd><p>Find what is the next element cut by the intface:
it is entered by the edge, it is adjacent to the
cut element and it is activated</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>elem2node</strong> (<em>list</em><em>(</em><em>list</em><em>(</em><em>int</em><em>)</em><em>)</em>) – elem2node connectivity of a partially cut mesh</p></li>
<li><p><strong>coords</strong> (<em>list</em><em>(</em><em>np.array</em><em>)</em>) – list of points</p></li>
<li><p><strong>intface</strong> (<a class="reference internal" href="#mesh_manager.disk_interface" title="mesh_manager.disk_interface"><em>disk_interface</em></a>) – interface</p></li>
<li><p><strong>ied</strong> (<em>int</em>) – idx of edge to check</p></li>
<li><p><strong>cut_iel</strong> (<em>int</em>) – last cut element</p></li>
<li><p><strong>intsec_points</strong> (<em>list</em><em>(</em><em>int</em><em>)</em>) – list of points intersections with cut elem</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>index of entered element (which is next to be cut)</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>iel_to_cut (int)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mesh_manager.get_final_agglomerating">
<span class="sig-prename descclassname"><span class="pre">mesh_manager.</span></span><span class="sig-name descname"><span class="pre">get_final_agglomerating</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">agglomerations</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iag</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mesh_manager.get_final_agglomerating" title="Permalink to this definition"></a></dt>
<dd><p>Internal procedure of agglomerate:
Same element can find itself to be agglomerated several times,
Get final element that ends up agglomerating element with index iag</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>agglomerations</strong> (<em>list</em><em>(</em><em>list</em><em>(</em><em>int</em><em>)</em><em>)</em>) – list of agglomerations to perform</p></li>
<li><p><strong>iag</strong> (<em>int</em>) – index in list of agglomerations</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mesh_manager.get_intersections">
<span class="sig-prename descclassname"><span class="pre">mesh_manager.</span></span><span class="sig-name descname"><span class="pre">get_intersections</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coords</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">elem</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">intface</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ied</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mesh_manager.get_intersections" title="Permalink to this definition"></a></dt>
<dd><p>Finds intersections between a simlpicial mesh element and an interface edge</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>coords</strong> (<em>list</em><em>(</em><em>np.array</em><em>)</em>) – list of points</p></li>
<li><p><strong>elem</strong> (<em>list</em><em>(</em><em>np.array</em><em>)</em>) – elem to intersect (list of points)</p></li>
<li><p><strong>intface</strong> (<a class="reference internal" href="#mesh_manager.disk_interface" title="mesh_manager.disk_interface"><em>disk_interface</em></a>) – interface</p></li>
<li><p><strong>ied</strong> (<em>int</em>) – edge index</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>intersection coordinates (if any)
cut_elem_edges (list): edges that are cut</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>intersections (list)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mesh_manager.get_intface_data">
<span class="sig-prename descclassname"><span class="pre">mesh_manager.</span></span><span class="sig-name descname"><span class="pre">get_intface_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iel</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mesh_manager.get_intface_data" title="Permalink to this definition"></a></dt>
<dd><p>Returns [cut, no_edges, first_ie] (data are used to update cuts field of agglomeratr mesh)
:type mesh: 
:param mesh: mesh
:type mesh: mesh2D
:type iel: 
:param iel: element index
:type iel: int</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mesh_manager.glob_idx">
<span class="sig-prename descclassname"><span class="pre">mesh_manager.</span></span><span class="sig-name descname"><span class="pre">glob_idx</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iel</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ino</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mesh_manager.glob_idx" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mesh_manager.initialize_disk_interface">
<span class="sig-prename descclassname"><span class="pre">mesh_manager.</span></span><span class="sig-name descname"><span class="pre">initialize_disk_interface</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rho</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k_b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k_str</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mesh_manager.initialize_disk_interface" title="Permalink to this definition"></a></dt>
<dd><p>Create a brand-new disk interface</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>N</strong> (<em>int</em>) – number of edges/nodes</p></li>
<li><p><strong>rho</strong> (<em>float</em>) – radius of the disk</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mesh_manager.is_cut">
<span class="sig-prename descclassname"><span class="pre">mesh_manager.</span></span><span class="sig-name descname"><span class="pre">is_cut</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iel</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rho</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mesh_manager.is_cut" title="Permalink to this definition"></a></dt>
<dd><p>checks if face is intersected by disk with radius rho</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mesh_manager.is_proper">
<span class="sig-prename descclassname"><span class="pre">mesh_manager.</span></span><span class="sig-name descname"><span class="pre">is_proper</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mesh_manager.is_proper" title="Permalink to this definition"></a></dt>
<dd><p>Checks if value is real and in interval(0,1].</p>
<p>Parameters:
- value: numerical value to check</p>
<p>Returns:
True or False</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mesh_manager.kron">
<span class="sig-prename descclassname"><span class="pre">mesh_manager.</span></span><span class="sig-name descname"><span class="pre">kron</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">j</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mesh_manager.kron" title="Permalink to this definition"></a></dt>
<dd><p>Kronecker delta</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mesh_manager.load_square_mesh">
<span class="sig-prename descclassname"><span class="pre">mesh_manager.</span></span><span class="sig-name descname"><span class="pre">load_square_mesh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bnd_dof_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'edge'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mesh_manager.load_square_mesh" title="Permalink to this definition"></a></dt>
<dd><p>Loads and parses a 2D mesh in msh format</p>
<p>Parameters:
- filename: path to the mesh file
- no_points_per_elem = increase size of elem2edge columns to fit polygonal elements
- bnd_dof_type (logical): type of dofs on the boundary</p>
<p>Returns:
- Mesh object</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mesh_manager.mark_bad_quality_elements">
<span class="sig-prename descclassname"><span class="pre">mesh_manager.</span></span><span class="sig-name descname"><span class="pre">mark_bad_quality_elements</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reference_mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cryt_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cryt_skewness</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mesh_manager.mark_bad_quality_elements" title="Permalink to this definition"></a></dt>
<dd><p>Provides a quality mask for mesh elements
:type mesh: 
:param mesh: mesh
:type mesh: mema.2Dmesh
:type reference_mesh: 
:param reference_mesh: uncut mesh
:type reference_mesh: mesh2D
:type cryt_size: 
:param cryt_size: minimal accepted size relative to standard far-from interface simplex
:type cryt_size: float
:type cryt_skewness: 
:param cryt_skewness: maximal accepted aspect ratio (skewness)
:type cryt_skewness: float</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 if good quality, 1 if bad</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>list (int)</p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mesh_manager.mesh2D">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mesh_manager.</span></span><span class="sig-name descname"><span class="pre">mesh2D</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">elem2node</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coords</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bnd_dof_type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mesh_manager.mesh2D" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Mesh Class. Supports broken elements.
It features both elem2edge and elem2node connectivity.
It incorporates information about the phase and interface edges.</p>
<p>Attributes:</p>
<p>elem2node   (list(list(int))): element 2 node connectivity
elem2edge  (list(list(int))): element 2 edge connectivity
coords (list(np.array)): node coordinates, 2 components
side_mask (list): element mask to define phase (0 int, 1 ext)
node_bnd_mask  (list(int)): node mask to define if on border and what border (0 if internal, k if on boundary k)
edge_bnd_mask  (list(int)): edge mask to define if on border
cuts (list): for each cut a list in the form: [couple, starting_ie, edge2intface]</p>
<blockquote>
<div><p>couple: elements along the cut [in, ex]
starting_ie: local idx of first edge along cut[in, ex]
edge2intface: map from edge on cut to idx on intface</p>
</div></blockquote>
<p>intface_edges       (list): list of interface edges (global index)
d                  (float): semi-side of box (necessary for marking boundary nodes)</p>
<p>How to loop over interface edges:
loop over cuts, and run over element edges using index of first and len(edge2intface)</p>
<dl class="py method">
<dt class="sig sig-object py" id="mesh_manager.mesh2D.barycenter">
<span class="sig-name descname"><span class="pre">barycenter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iel</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mesh_manager.mesh2D.barycenter" title="Permalink to this definition"></a></dt>
<dd><p>Determines barycenter of polygonal element
(using shoelace formula)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>iel</strong> (<em>int</em>) – element index</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>barycenter</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.array(float)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mesh_manager.mesh2D.calc_surface">
<span class="sig-name descname"><span class="pre">calc_surface</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iel</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mesh_manager.mesh2D.calc_surface" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mesh_manager.mesh2D.generate_edge2elem">
<span class="sig-name descname"><span class="pre">generate_edge2elem</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mesh_manager.mesh2D.generate_edge2elem" title="Permalink to this definition"></a></dt>
<dd><p>Calculates edge 2 element connectivity</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mesh_manager.mesh2D.generate_elem2edge">
<span class="sig-name descname"><span class="pre">generate_elem2edge</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mesh_manager.mesh2D.generate_elem2edge" title="Permalink to this definition"></a></dt>
<dd><p>Creates the local to global map for edges self.elem2edge</p>
<p>Parameters:
- self (self2D): self</p>
<p>Returns:
- list of int: self to replace to self.elem2edge</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mesh_manager.mesh2D.generate_elem2elem">
<span class="sig-name descname"><span class="pre">generate_elem2elem</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mesh_manager.mesh2D.generate_elem2elem" title="Permalink to this definition"></a></dt>
<dd><p>Generates elem2elem connectivity (elements sharing one edge standing on same side)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mesh_manager.mesh2D.generate_intface_edges">
<span class="sig-name descname"><span class="pre">generate_intface_edges</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mesh_manager.mesh2D.generate_intface_edges" title="Permalink to this definition"></a></dt>
<dd><p>Creates self.intface_edges (list of global indexes of interface edges)
Edges are not in ascending ordered,
position is correlated to order on interface (not perfectly though)</p>
<p>Parameters:
- self (self2D): self</p>
<p>Returns:
- list: list to replace as self.intface_edges</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mesh_manager.mesh2D.get_edge_length">
<span class="sig-name descname"><span class="pre">get_edge_length</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iel</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ie</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mesh_manager.mesh2D.get_edge_length" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>iel</strong> (<em>int</em>) – element index</p></li>
<li><p><strong>ie</strong> (<em>int</em>) – index of face</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>length of the edge ie</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
<p>Raises:
ValueError: If the result is 0.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mesh_manager.mesh2D.get_edge_normal">
<span class="sig-name descname"><span class="pre">get_edge_normal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iel</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_face</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mesh_manager.mesh2D.get_edge_normal" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>self</strong> (<em>ddr.self2D</em>) – self</p></li>
<li><p><strong>iel</strong> (<em>int</em>) – element index</p></li>
<li><p><strong>num_face</strong> (<em>int</em>) – index of face</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>edge normal</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.array(float)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mesh_manager.mesh2D.get_mesh_size">
<span class="sig-name descname"><span class="pre">get_mesh_size</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mesh_manager.mesh2D.get_mesh_size" title="Permalink to this definition"></a></dt>
<dd><p>Provides minimal and maximal element size
(taken as sqr of surface)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mesh_manager.mesh2D.get_xE">
<span class="sig-name descname"><span class="pre">get_xE</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iel</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ie</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mesh_manager.mesh2D.get_xE" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>iel</strong> (<em>int</em>) – element index</p></li>
<li><p><strong>ie</strong> (<em>int</em>) – index of edge</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>barycenter of edge</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mesh_manager.mesh2D.mark_bnd_edges">
<span class="sig-name descname"><span class="pre">mark_bnd_edges</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mesh_manager.mesh2D.mark_bnd_edges" title="Permalink to this definition"></a></dt>
<dd><p>Sets mask for edges lying on boundary (no distinction between sections of boundary)</p>
<p>Returns: void</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mesh_manager.mesh2D.mark_bnd_points">
<span class="sig-name descname"><span class="pre">mark_bnd_points</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mesh_manager.mesh2D.mark_bnd_points" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Assigns the boundary mask for points;
It only works for square boxes</p>
<p>Convention:</p>
</div></blockquote>
<dl class="simple">
<dt>-1: internal</dt><dd><p>1: x=-d
2: y=-d
3: x= d
4: y= d</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mesh_manager.move_critical_points">
<span class="sig-prename descclassname"><span class="pre">mesh_manager.</span></span><span class="sig-name descname"><span class="pre">move_critical_points</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rho</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mesh_manager.move_critical_points" title="Permalink to this definition"></a></dt>
<dd><p>Displace critical points which are too close to the interface
(avoid rare but nasty situations of elements not properly cut)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mesh_manager.point_is_inside">
<span class="sig-prename descclassname"><span class="pre">mesh_manager.</span></span><span class="sig-name descname"><span class="pre">point_is_inside</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">polygon</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mesh_manager.point_is_inside" title="Permalink to this definition"></a></dt>
<dd><p>Determine if point is inside a polygon
:type polygon: 
:param polygon: polygon as list of points
:type polygon: list(np.array)
:type q: 
:param q: point to check
:type q: np.array</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>boolean</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mesh_manager.rotate_90_clockwise">
<span class="sig-prename descclassname"><span class="pre">mesh_manager.</span></span><span class="sig-name descname"><span class="pre">rotate_90_clockwise</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vec</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mesh_manager.rotate_90_clockwise" title="Permalink to this definition"></a></dt>
<dd><p>Rotate a vector 90 degrees clockwise
:type vec: 
:param vec: vector in R^2
:type vec: np.array</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>rotated vector in R^2</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(np.arrya)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mesh_manager.share_an_edge">
<span class="sig-prename descclassname"><span class="pre">mesh_manager.</span></span><span class="sig-name descname"><span class="pre">share_an_edge</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">elem2node</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iel1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iel2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mesh_manager.share_an_edge" title="Permalink to this definition"></a></dt>
<dd><p>Determine whether two elemnts share an edge</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>elem2node</strong> (<em>list</em><em>(</em><em>list</em><em>(</em><em>int</em><em>)</em><em>)</em>) – element2node connectivity</p></li>
<li><p><strong>iel1</strong> (<em>int</em>) – first elem index</p></li>
<li><p><strong>iel2</strong> (<em>int</em>) – second elem index</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>boolean</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mesh_manager.suppress_elements">
<span class="sig-prename descclassname"><span class="pre">mesh_manager.</span></span><span class="sig-name descname"><span class="pre">suppress_elements</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">elem2node</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cuts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">list_of_elems</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mesh_manager.suppress_elements" title="Permalink to this definition"></a></dt>
<dd><p>Suppress elements from mesh
cuts field is updated accordingly
:type elem2node: 
:param elem2node: element to node connectivity
:type elem2node: list(list(int))
:type cuts: 
:param cuts: cuts field (interface-related data)
:type cuts: list
:type list_of_elems: 
:param list_of_elems: list of elements to suppress
:type list_of_elems: list(int)</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>new element to node connectivity
cuts: new cuts field</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>new_elem2node</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mesh_manager.visualize_intface">
<span class="sig-prename descclassname"><span class="pre">mesh_manager.</span></span><span class="sig-name descname"><span class="pre">visualize_intface</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fig</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">intface</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show_velocity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show_tension</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show_nodes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mark_first_node</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show_edge_idx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mesh_manager.visualize_intface" title="Permalink to this definition"></a></dt>
<dd><p>Plots interface</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fig</strong> – figure</p></li>
<li><p><strong>ax</strong> – axis</p></li>
<li><p><strong>intface</strong> (<em>mema.disk_interface</em>) – interface to plot</p></li>
<li><p><strong>show_velocity</strong> (<em>boolean</em>) – whether to show arrows for velocity</p></li>
<li><p><strong>show_tension</strong> (<em>boolean</em>) – whether to show arrows for tension</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mesh_manager.visualize_intface_nodal_vector">
<span class="sig-prename descclassname"><span class="pre">mesh_manager.</span></span><span class="sig-name descname"><span class="pre">visualize_intface_nodal_vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fig</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">intface</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vector_data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mesh_manager.visualize_intface_nodal_vector" title="Permalink to this definition"></a></dt>
<dd><p>Plots interface</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fig</strong> – figure</p></li>
<li><p><strong>ax</strong> – axis</p></li>
<li><p><strong>intface</strong> (<em>mema.disk_interface</em>) – interface</p></li>
<li><p><strong>vector_data</strong> – edge-wise data to plot</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mesh_manager.visualize_intface_vector">
<span class="sig-prename descclassname"><span class="pre">mesh_manager.</span></span><span class="sig-name descname"><span class="pre">visualize_intface_vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fig</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">intface</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vector_data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mesh_manager.visualize_intface_vector" title="Permalink to this definition"></a></dt>
<dd><p>Plots interface</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fig</strong> – figure</p></li>
<li><p><strong>ax</strong> – axis</p></li>
<li><p><strong>intface</strong> (<em>mema.disk_interface</em>) – interface</p></li>
<li><p><strong>vector_data</strong> – edge-wise data to plot</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mesh_manager.visualize_mesh">
<span class="sig-prename descclassname"><span class="pre">mesh_manager.</span></span><span class="sig-name descname"><span class="pre">visualize_mesh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">display_no_nodes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">display_side</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">display_couples</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cmap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'magma'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">display_node_id</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show_barycenter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mesh_manager.visualize_mesh" title="Permalink to this definition"></a></dt>
<dd><p>Display mesh and related info</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>display_no_nodes</strong> (<em>boolean</em>) – whther to show number of nodes of each element</p></li>
<li><p><strong>display_side</strong> (<em>boolean</em>) – whether to display color of side</p></li>
<li><p><strong>display_node_id</strong> (<em>boolean</em>) – whether to show index of nodes</p></li>
<li><p><strong>show_barycenter</strong> (<em>boolean</em>) – whether to show element barycenter</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mesh_manager.visualize_mesh_element_data">
<span class="sig-prename descclassname"><span class="pre">mesh_manager.</span></span><span class="sig-name descname"><span class="pre">visualize_mesh_element_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">binary</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cmap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'magma'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mesh_manager.visualize_mesh_element_data" title="Permalink to this definition"></a></dt>
<dd><p>Display mesh and related info</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>list</em><em>(</em><em>float</em><em>)</em>) – element-wise scalar data</p></li>
<li><p><strong>binary</strong> (<em>boolean</em>) – wether the data assumes only two values</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-HHO_stokes">
<span id="module-hho-stokes"></span><h2>Module: HHO_stokes<a class="headerlink" href="#module-HHO_stokes" title="Permalink to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="HHO_stokes.assemble_A">
<span class="sig-prename descclassname"><span class="pre">HHO_stokes.</span></span><span class="sig-name descname"><span class="pre">assemble_A</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nu_in</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nu_ex</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HHO_stokes.assemble_A" title="Permalink to this definition"></a></dt>
<dd><p>Assembles matrix A (constant viscosity)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mesh</strong> (<em>ddr.Mesh</em>) – mesh</p></li>
<li><p><strong>nu_in</strong> (<em>float</em>) – viscosity internal</p></li>
<li><p><strong>nu_ext</strong> (<em>float</em>) – viscosity external</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>matrix A</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.array(no_v_dofs, no_v_dofs)</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ErrorType</strong> – Description of when this error might be raised.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="HHO_stokes.assemble_B">
<span class="sig-prename descclassname"><span class="pre">HHO_stokes.</span></span><span class="sig-name descname"><span class="pre">assemble_B</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HHO_stokes.assemble_B" title="Permalink to this definition"></a></dt>
<dd><p>Assembles matrix B</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>mesh</strong> (<em>ddr.Mesh</em>) – mesh</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>matrix B</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.array(no_v_dofs, no_p_dofs)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="HHO_stokes.assemble_JP">
<span class="sig-prename descclassname"><span class="pre">HHO_stokes.</span></span><span class="sig-name descname"><span class="pre">assemble_JP</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HHO_stokes.assemble_JP" title="Permalink to this definition"></a></dt>
<dd><p>Assembles the Jump Penalisation term,
necessary to recover stability at lowest order (k=0)
See di2020hybrid, sec. 7.6</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>mesh</strong> (<em>mema.2Dmesh</em>) – mesh</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>JP (jump penalisation matrix)</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.array</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="HHO_stokes.assemble_STAB">
<span class="sig-prename descclassname"><span class="pre">HHO_stokes.</span></span><span class="sig-name descname"><span class="pre">assemble_STAB</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HHO_stokes.assemble_STAB" title="Permalink to this definition"></a></dt>
<dd><p>Assembles only stabilisation component of matrix A (debugging purpose)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>mesh</strong> (<em>ddr.Mesh</em>) – mesh</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>matrix STAB</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.array(no_v_dofs, no_v_dofs)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="HHO_stokes.assemble_b_f">
<span class="sig-prename descclassname"><span class="pre">HHO_stokes.</span></span><span class="sig-name descname"><span class="pre">assemble_b_f</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HHO_stokes.assemble_b_f" title="Permalink to this definition"></a></dt>
<dd><p>Assembles vector b_f associated to &lt;f, v&gt;</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mesh</strong> (<em>ddr.Mesh</em>) – mesh</p></li>
<li><p><strong>f</strong> (<em>lambda function</em>) – forcing term</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>vector b</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.array(no_v_dofs)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="HHO_stokes.assemble_b_gamma">
<span class="sig-prename descclassname"><span class="pre">HHO_stokes.</span></span><span class="sig-name descname"><span class="pre">assemble_b_gamma</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t_gamma</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HHO_stokes.assemble_b_gamma" title="Permalink to this definition"></a></dt>
<dd><p>Assembles operator associated to surface tension
$tau_Gamma$</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mesh</strong> (<em>mema.Mesh</em>) – mesh</p></li>
<li><p><strong>tau_gamma</strong> (<em>list</em><em>(</em><em>np.array</em>) – edge-wise surface tension</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>linear system system vector tau</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.array(no_v_dofs)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="HHO_stokes.count_dof">
<span class="sig-prename descclassname"><span class="pre">HHO_stokes.</span></span><span class="sig-name descname"><span class="pre">count_dof</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HHO_stokes.count_dof" title="Permalink to this definition"></a></dt>
<dd><p>Calculate total number of degrees of freedom of the solver
(size of the linear system)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>mesh</strong> (<em>ddr.mesh2D</em>) – mesh</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>number of dofs for pressure, for velocity and linear system size</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list (int)</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ErrorType</strong> – Description of when this error might be raised.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="HHO_stokes.dof_loc2glob">
<span class="sig-prename descclassname"><span class="pre">HHO_stokes.</span></span><span class="sig-name descname"><span class="pre">dof_loc2glob</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iel</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc_dof</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HHO_stokes.dof_loc2glob" title="Permalink to this definition"></a></dt>
<dd><p>Maps local dof index to global dof index</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mesh</strong> (<em>ddr.mesh2D</em>) – mesh</p></li>
<li><p><strong>iel</strong> (<em>int</em>) – element index</p></li>
<li><p><strong>loc_dof</strong> (<em>int</em>) – local degree of freedom</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>global dof index</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>int</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ErrorType</strong> – Description of when this error might be raised.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="HHO_stokes.elem_velocity_energy_norm">
<span class="sig-prename descclassname"><span class="pre">HHO_stokes.</span></span><span class="sig-name descname"><span class="pre">elem_velocity_energy_norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iel</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v_h</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HHO_stokes.elem_velocity_energy_norm" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mesh</strong> (<a class="reference internal" href="#mesh_manager.mesh2D" title="mesh_manager.mesh2D"><em>mesh2D</em></a>) – mesh</p></li>
<li><p><strong>iel</strong> (<em>int</em>) – elem index</p></li>
<li><p><strong>v_h</strong> (<em>np.array</em><em>(</em><em>float</em><em>)</em>) – velocity (coefficients in HHO space), dim=no_v_dofs (only velocity array)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="HHO_stokes.get_disc_div">
<span class="sig-prename descclassname"><span class="pre">HHO_stokes.</span></span><span class="sig-name descname"><span class="pre">get_disc_div</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iel</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dof</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HHO_stokes.get_disc_div" title="Permalink to this definition"></a></dt>
<dd><p>Provides coefficients of r^{k+1}_T for the local basis function
associated to the local degree of freedom w.r.t. the canonical basis.
i.e. returns [A, b] if r^{k+1}_T = A*(x-xT)+ b (x, xT, b are in R^2)
In particular, A is the gradient to use in aT, and b is the average</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mesh</strong> (<em>ddr.Mesh</em>) – mesh</p></li>
<li><p><strong>iel</strong> (<em>int</em>) – element index</p></li>
<li><p><strong>dof</strong> (<em>int</em>) – local degree of freedom</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A (grad r^{k+1}_T)
np.array       (2*1): b</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.array       (2*2)</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>...</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="HHO_stokes.get_disc_div_from_localV">
<span class="sig-prename descclassname"><span class="pre">HHO_stokes.</span></span><span class="sig-name descname"><span class="pre">get_disc_div_from_localV</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iel</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">localV</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HHO_stokes.get_disc_div_from_localV" title="Permalink to this definition"></a></dt>
<dd><p>Discrete divergence</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mesh</strong> (<em>ddr.Mesh</em>) – mesh</p></li>
<li><p><strong>iel</strong> (<em>int</em>) – element index</p></li>
<li><p><strong>localV</strong> (<em>np.array</em><em>, </em><em>2*1+no_edges</em>) – local function (v_T, {v_E}_E)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>dicrete divergence (p0(T): constant)</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>...</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="HHO_stokes.get_edge_dofs">
<span class="sig-prename descclassname"><span class="pre">HHO_stokes.</span></span><span class="sig-name descname"><span class="pre">get_edge_dofs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iel</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ie</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HHO_stokes.get_edge_dofs" title="Permalink to this definition"></a></dt>
<dd><p>Description: returns 2 velocity edge dofs given element index and local edge index</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mesh</strong> (<em>ddr.mesh2D</em>) – mesh</p></li>
<li><p><strong>iel</strong> (<em>int</em>) – element index</p></li>
<li><p><strong>ie</strong> (<em>int</em>) – local index of edge</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>dof_x, dof_y</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list        (int)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="HHO_stokes.get_local_interpolation">
<span class="sig-prename descclassname"><span class="pre">HHO_stokes.</span></span><span class="sig-name descname"><span class="pre">get_local_interpolation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iel</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ref_v</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HHO_stokes.get_local_interpolation" title="Permalink to this definition"></a></dt>
<dd><p>Provides local p0 polynomials associated to a velocity dof,
with the convention [v_T, {v_F}_F].
v_T is p0(T)^2, v_F is p0(F)^2 for each F</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>mesh</strong> (<em>ddr.Mesh</em>) – mesh</p>
</dd>
</dl>
<p>iel               (int): element index
ref_v          (lambda): H1 velocity to interpolate</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>local p0 polynomials (R^2 constants) (underline{v}_T)</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>np.array  (2*(1+num_edge))</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>...</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="HHO_stokes.get_local_polynomials">
<span class="sig-prename descclassname"><span class="pre">HHO_stokes.</span></span><span class="sig-name descname"><span class="pre">get_local_polynomials</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iel</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dof</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HHO_stokes.get_local_polynomials" title="Permalink to this definition"></a></dt>
<dd><p>Provides local p0 polynomials associated to a velocity dof,
with the convention [v_T, {v_F}_F].
v_T is p0(T)^2, v_F is p0(F)^2 for each F</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mesh</strong> (<em>ddr.Mesh</em>) – mesh</p></li>
<li><p><strong>iel</strong> (<em>int</em>) – element index</p></li>
<li><p><strong>dof</strong> (<em>int</em>) – local degree of freedom</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>local p0 polynomials (R^2 constants)</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list (np.array(2)) len=(1+num_edge))</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>...</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="HHO_stokes.get_local_projections">
<span class="sig-prename descclassname"><span class="pre">HHO_stokes.</span></span><span class="sig-name descname"><span class="pre">get_local_projections</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iel</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ref_v</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HHO_stokes.get_local_projections" title="Permalink to this definition"></a></dt>
<dd><p>Given a reference velocity, computes the
projection over the local basis functions
and packs them into an array (usual convention for ordering).
Combining get_local_polynomials and get_local_projections
should be the same as get_local_interpolation</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mesh</strong> (<em>ddr.Mesh</em>) – mesh</p></li>
<li><p><strong>iel</strong> (<em>int</em>) – element index</p></li>
<li><p><strong>dof</strong> (<em>int</em>) – local degree of freedom</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>local projections</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.array  (no_loc_dofs)</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>...</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="HHO_stokes.get_local_velocities">
<span class="sig-prename descclassname"><span class="pre">HHO_stokes.</span></span><span class="sig-name descname"><span class="pre">get_local_velocities</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iel</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v_h</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HHO_stokes.get_local_velocities" title="Permalink to this definition"></a></dt>
<dd><p>Provides local velocities associated to element
w.r.t. a global velocity unknown v_h
with the convention [v_T, {v_E}_E].
v_T is p0(T)^2, v_E is p0(E)^2 for each E</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mesh</strong> (<em>ddr.Mesh</em>) – mesh</p></li>
<li><p><strong>iel</strong> (<em>int</em>) – element index</p></li>
<li><p><strong>v_h</strong> (<em>np_array</em>) – local degree of freedom</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>local velocities [v_T, {v_E}]</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list (np.array(2)) len=(1+num_edge))</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="HHO_stokes.get_v_rec">
<span class="sig-prename descclassname"><span class="pre">HHO_stokes.</span></span><span class="sig-name descname"><span class="pre">get_v_rec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iel</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dof</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HHO_stokes.get_v_rec" title="Permalink to this definition"></a></dt>
<dd><p>Provides coefficients of r^{k+1}_T for the local basis function
associated to the local degree of freedom w.r.t. the canonical basis.
i.e. returns [A, b] if r^{k+1}_T = A*(x-xT)+ b (x, xT, b are in R^2)
In particular, A is the gradient to use in aT, and b is the average</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mesh</strong> (<em>ddr.Mesh</em>) – mesh</p></li>
<li><p><strong>iel</strong> (<em>int</em>) – element index</p></li>
<li><p><strong>dof</strong> (<em>int</em>) – local degree of freedom</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A (grad r^{k+1}_T)
np.array       (2*1): b</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.array       (2*2)</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>...</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="HHO_stokes.get_v_rec_from_localV">
<span class="sig-prename descclassname"><span class="pre">HHO_stokes.</span></span><span class="sig-name descname"><span class="pre">get_v_rec_from_localV</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iel</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">localV</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HHO_stokes.get_v_rec_from_localV" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mesh</strong> (<em>ddr.Mesh</em>) – mesh</p></li>
<li><p><strong>iel</strong> (<em>int</em>) – element index</p></li>
<li><p><strong>list</strong> (<em>localV</em>) – local function (v_T, {v_E}_E)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A (grad r^{k+1}_T)
np.array       (2*1): b (1/mod_T*int_T r^{k+1}_T : element average)</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.array       (2*2)</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>...</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="HHO_stokes.impose_bc">
<span class="sig-prename descclassname"><span class="pre">HHO_stokes.</span></span><span class="sig-name descname"><span class="pre">impose_bc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ref_sol_v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zero_mean</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HHO_stokes.impose_bc" title="Permalink to this definition"></a></dt>
<dd><p>Forces Dirichlet boundary conditions on velocity
Enlarges the system with one line to account for zero mean pressure</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mesh</strong> (<em>ddr.Mesh</em>) – mesh</p></li>
<li><p><strong>S</strong> (<em>np.array</em>) – global system matrix</p></li>
<li><p><strong>b</strong> (<em>np.array</em>) – global system vector</p></li>
<li><p><strong>ref_sol_v</strong> (<em>lambda</em>) – reference velocity</p></li>
<li><p><strong>zero_mean</strong> (<em>boolean</em>) – True if you want to force zero mean for pressure</p></li>
</ul>
</dd>
</dl>
<dl class="simple">
<dt>Returns: S (np.array): global system matrix</dt><dd><p>b (np.array): global system array</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="HHO_stokes.interpolate_pressure">
<span class="sig-prename descclassname"><span class="pre">HHO_stokes.</span></span><span class="sig-name descname"><span class="pre">interpolate_pressure</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ref_p</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HHO_stokes.interpolate_pressure" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mesh</strong> (<em>ddr.Mesh</em>) – mesh</p></li>
<li><p><strong>ref_p</strong> (<em>lambda</em>) – reference pressure</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>discrete pressure</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.array(no_p_dofs)</p>
</dd>
</dl>
<p>Remarks: L2 projection over T is replaced by value in barycenter</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="HHO_stokes.interpolate_solution">
<span class="sig-prename descclassname"><span class="pre">HHO_stokes.</span></span><span class="sig-name descname"><span class="pre">interpolate_solution</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ref_p</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ref_v</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HHO_stokes.interpolate_solution" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mesh</strong> (<em>ddr.Mesh</em>) – mesh</p></li>
<li><p><strong>ref_p</strong> (<em>lambda</em>) – reference pressure</p></li>
<li><p><strong>ref_v</strong> (<em>lambda</em>) – reference velocity</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>discrete solution in the conventinal format [p_h, v_h]</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.array(no_tot_dofs)</p>
</dd>
</dl>
<p>Remarks: L2 projection over T/E replaced by value in barycenter</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="HHO_stokes.interpolate_velocity">
<span class="sig-prename descclassname"><span class="pre">HHO_stokes.</span></span><span class="sig-name descname"><span class="pre">interpolate_velocity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ref_v</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HHO_stokes.interpolate_velocity" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mesh</strong> (<em>ddr.Mesh</em>) – mesh</p></li>
<li><p><strong>ref_v</strong> (<em>lambda</em>) – reference velocity</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>discrete velocity</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.array(no_v_dofs)</p>
</dd>
</dl>
<p>Remarks: L2 projection over T/E replaced by value in barycenter</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="HHO_stokes.loc_dof_description">
<span class="sig-prename descclassname"><span class="pre">HHO_stokes.</span></span><span class="sig-name descname"><span class="pre">loc_dof_description</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iel</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc_dof</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HHO_stokes.loc_dof_description" title="Permalink to this definition"></a></dt>
<dd><p>Returns description of the local dof (p/V, x/y, T/F, face_number)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mesh</strong> (<em>ddr.mesh2D</em>) – mesh</p></li>
<li><p><strong>iel</strong> – index of elem</p></li>
<li><p><strong>loc_dof</strong> (<em>int</em>) – local degree of freedom</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>[“p”/”V”, “-“/x”/”y”, “T”/”F”, face_number]</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list of str</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>...</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="HHO_stokes.local_contribution_aT">
<span class="sig-prename descclassname"><span class="pre">HHO_stokes.</span></span><span class="sig-name descname"><span class="pre">local_contribution_aT</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iel</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">j</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nu</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HHO_stokes.local_contribution_aT" title="Permalink to this definition"></a></dt>
<dd><p>Calculate local contribution aT (grad:grad)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mesh</strong> (<em>ddr.Mesh</em>) – mesh</p></li>
<li><p><strong>iel</strong> (<em>int</em>) – element index</p></li>
<li><p><strong>i</strong> (<em>int</em>) – local dof 1</p></li>
<li><p><strong>j</strong> (<em>int</em>) – local dof 2</p></li>
<li><p><strong>nu</strong> (<em>float</em>) – element viscosity</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>local contribution</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>real</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>...</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="HHO_stokes.local_contribution_bT">
<span class="sig-prename descclassname"><span class="pre">HHO_stokes.</span></span><span class="sig-name descname"><span class="pre">local_contribution_bT</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iel</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HHO_stokes.local_contribution_bT" title="Permalink to this definition"></a></dt>
<dd><p>Calculate local contribution bT (coupling v,p)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mesh</strong> (<em>ddr.Mesh</em>) – mesh</p></li>
<li><p><strong>iel</strong> (<em>int</em>) – element index</p></li>
<li><p><strong>i</strong> (<em>int</em>) – local dof associated to v</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>local contribution</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>real</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="HHO_stokes.local_contribution_fT">
<span class="sig-prename descclassname"><span class="pre">HHO_stokes.</span></span><span class="sig-name descname"><span class="pre">local_contribution_fT</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iel</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dof</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HHO_stokes.local_contribution_fT" title="Permalink to this definition"></a></dt>
<dd><p>Calculate local contribution fT (forcing term)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mesh</strong> (<em>ddr.Mesh</em>) – mesh</p></li>
<li><p><strong>iel</strong> (<em>int</em>) – element index</p></li>
<li><p><strong>f</strong> (<em>lambda function</em>) – forcing term</p></li>
<li><p><strong>dof</strong> (<em>int</em>) – local dof</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>local contribution</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>real</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="HHO_stokes.local_contribution_sT">
<span class="sig-prename descclassname"><span class="pre">HHO_stokes.</span></span><span class="sig-name descname"><span class="pre">local_contribution_sT</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iel</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">j</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HHO_stokes.local_contribution_sT" title="Permalink to this definition"></a></dt>
<dd><p>Calculate local contribution sT (stabilization)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mesh</strong> (<em>ddr.Mesh</em>) – mesh</p></li>
<li><p><strong>iel</strong> (<em>int</em>) – element index</p></li>
<li><p><strong>i</strong> (<em>int</em>) – local dof 1</p></li>
<li><p><strong>j</strong> (<em>int</em>) – local dof 2</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>local contribution</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>real</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>...</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="HHO_stokes.p_v_error">
<span class="sig-prename descclassname"><span class="pre">HHO_stokes.</span></span><span class="sig-name descname"><span class="pre">p_v_error</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_v_lambda</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ref_p</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ref_v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalized</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HHO_stokes.p_v_error" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mesh</strong> (<a class="reference internal" href="#mesh_manager.mesh2D" title="mesh_manager.mesh2D"><em>mesh2D</em></a>) – mesh</p></li>
<li><p><strong>p_v_lambda</strong> (<em>np.array</em><em>(</em><em>float</em><em>)</em>) – HHO-stokes solution (with 1 DOF for Lagrange multiplier)</p></li>
<li><p><strong>ref_p</strong> (<em>lambda</em>) – reference pressure</p></li>
<li><p><strong>ref_v</strong> (<em>lambda</em>) – reference velocity</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>[pressure L2 error, velocity energy error]</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list(float)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="HHO_stokes.pressure_L2_norm">
<span class="sig-prename descclassname"><span class="pre">HHO_stokes.</span></span><span class="sig-name descname"><span class="pre">pressure_L2_norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_h</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HHO_stokes.pressure_L2_norm" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mesh</strong> (<a class="reference internal" href="#mesh_manager.mesh2D" title="mesh_manager.mesh2D"><em>mesh2D</em></a>) – mesh</p></li>
<li><p><strong>p_h</strong> (<em>np.array</em><em>(</em><em>float</em><em>)</em>) – pressure (coefficients in HHO space) dim=no_p_dofs (only pressure array)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="HHO_stokes.solve_stokes">
<span class="sig-prename descclassname"><span class="pre">HHO_stokes.</span></span><span class="sig-name descname"><span class="pre">solve_stokes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ref_sol_v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vol_force</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nu_in</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nu_ex</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">intface</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_surface_tension</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">external_tension</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">jump_penalization</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HHO_stokes.solve_stokes" title="Permalink to this definition"></a></dt>
<dd><p>Solve Stokes problem with an interface and surface tension</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mesh</strong> (<em>mema.Mesh2D</em>) – mesh</p></li>
<li><p><strong>intface</strong> (<em>mema.disk_interface</em>) – interface</p></li>
<li><p><strong>ref_sol_v</strong> (<em>lambda</em>) – reference velocity</p></li>
<li><p><strong>vol_force</strong> (<em>lambda</em>) – </p></li>
<li><p><strong>nu</strong> (<em>float</em>) – viscosity (up to now uniform)</p></li>
<li><p><strong>external_tension</strong> (<em>list</em><em>(</em><em>np.array</em><em>)</em>) – external tension (e.g. Maxwell)</p></li>
<li><p><strong>jump_penalization</strong> (<em>boolean</em>) – whether o apply jump penalization</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>solution (p, v, lambda) where lambda</dt><dd><p>is Lagrange multiplier</p>
</dd>
</dl>
<p>S (np.array): global system matrix (after bnd conditions)
b (np.array): global system array  (after bnd conditions)
A (np.array): matrix grad_s:grad_s
B (np.array): matrix div*q
PJ(np.array): jump penalization
b_gamma (np.array): global system array  (after bnd conditions)</p>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>p_v_lambda  (np.array)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="HHO_stokes.transfer_velocity_and_advect_interface">
<span class="sig-prename descclassname"><span class="pre">HHO_stokes.</span></span><span class="sig-name descname"><span class="pre">transfer_velocity_and_advect_interface</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">intface</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_v_lambda</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">advect</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HHO_stokes.transfer_velocity_and_advect_interface" title="Permalink to this definition"></a></dt>
<dd><p>Displace interface transferring velocity from mesh edges</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mesh</strong> (<em>mema.Mesh2D</em>) – mesh</p></li>
<li><p><strong>intface</strong> (<em>mema.disk_intface</em>) – interface</p></li>
<li><p><strong>p_v_lambda</strong> (<em>np.array</em>) – stokes solution format (p,v,lambda)</p></li>
<li><p><strong>advect</strong> (<em>boolean</em>) – whether or not to advect</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>moved interface</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>disk_intface</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="HHO_stokes.velocity_energy_norm">
<span class="sig-prename descclassname"><span class="pre">HHO_stokes.</span></span><span class="sig-name descname"><span class="pre">velocity_energy_norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v_h</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HHO_stokes.velocity_energy_norm" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mesh</strong> (<a class="reference internal" href="#mesh_manager.mesh2D" title="mesh_manager.mesh2D"><em>mesh2D</em></a>) – mesh</p></li>
<li><p><strong>v_h</strong> (<em>np.array</em><em>(</em><em>float</em><em>)</em>) – velocity (coefficients in HHO space), dim=no_v_dofs (only velocity array)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="HHO_stokes.visualize_solution">
<span class="sig-prename descclassname"><span class="pre">HHO_stokes.</span></span><span class="sig-name descname"><span class="pre">visualize_solution</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v_p</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fig</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cmaps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">['magma',</span> <span class="pre">'viridis']</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arrows</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'edge'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arrow_density</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">6</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HHO_stokes.visualize_solution" title="Permalink to this definition"></a></dt>
<dd><p>Plots solution to Stokes Problem; on first axes velocity (magnitude),
on second axes pressure</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mesh</strong> (<em>ddr.Mesh</em>) – mesh</p></li>
<li><p><strong>v_p</strong> (<em>np.array</em>) – pressure_velocity_solution</p></li>
<li><p><strong>fig</strong> (<em>plt.figure</em>) – figure</p></li>
<li><p><strong>axes</strong> (<em>plt.axes</em>) – axes</p></li>
<li><p><strong>cmaps</strong> (<em>colormap</em>) – colormaps</p></li>
<li><p><strong>arrows</strong> (<em>string</em>) – if “edge” edge velocity is represented with arrows,
otherwise element velocity.</p></li>
<li><p><strong>arrow_density</strong> (<em>int</em>) – from 0 to 6 to increase arrows that are displayed</p></li>
</ul>
</dd>
</dl>
<p>Returns: void</p>
</dd></dl>

</section>
<section id="module-DDR_intface">
<span id="module-ddr-intface"></span><h2>Module: DDR_intface<a class="headerlink" href="#module-DDR_intface" title="Permalink to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="DDR_intface.assemble_G">
<span class="sig-prename descclassname"><span class="pre">DDR_intface.</span></span><span class="sig-name descname"><span class="pre">assemble_G</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma_in</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma_ex</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#DDR_intface.assemble_G" title="Permalink to this definition"></a></dt>
<dd><p>Assemble matrix G (grad-grad)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mesh</strong> (<em>mema.mesh2D</em>) – mesh</p></li>
<li><p><strong>sigma_in</strong> (<em>float</em>) – diff. coefficient internal</p></li>
<li><p><strong>sigma_ex</strong> (<em>float</em>) – diff. coefficient external</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="DDR_intface.assemble_M_gamma">
<span class="sig-prename descclassname"><span class="pre">DDR_intface.</span></span><span class="sig-name descname"><span class="pre">assemble_M_gamma</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma_in</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma_ex</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#DDR_intface.assemble_M_gamma" title="Permalink to this definition"></a></dt>
<dd><p>Assembles matrix M_gamma (gradient jump at interface)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mesh</strong> (<em>mema.mesh2D</em>) – mesh</p></li>
<li><p><strong>sigma_in</strong> (<em>float</em>) – diff. coefficient internal</p></li>
<li><p><strong>sigma_ex</strong> (<em>float</em>) – diff. coefficient external</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="DDR_intface.assemble_N_gamma">
<span class="sig-prename descclassname"><span class="pre">DDR_intface.</span></span><span class="sig-name descname"><span class="pre">assemble_N_gamma</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma_in</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma_ex</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#DDR_intface.assemble_N_gamma" title="Permalink to this definition"></a></dt>
<dd><p>Assembles matrix N_gamma (jump at interface of edge values)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mesh</strong> (<em>mema.mesh2D</em>) – mesh</p></li>
<li><p><strong>sigma_in</strong> (<em>float</em>) – diff. coefficient internal</p></li>
<li><p><strong>sigma_ex</strong> (<em>float</em>) – diff. coefficient external</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="DDR_intface.assemble_S">
<span class="sig-prename descclassname"><span class="pre">DDR_intface.</span></span><span class="sig-name descname"><span class="pre">assemble_S</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma_in</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma_ex</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#DDR_intface.assemble_S" title="Permalink to this definition"></a></dt>
<dd><p>Assemble matrix S (stabilization)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mesh</strong> (<em>mema.mesh2D</em>) – mesh</p></li>
<li><p><strong>sigma_in</strong> (<em>float</em>) – diff. coefficient internal</p></li>
<li><p><strong>sigma_ex</strong> (<em>float</em>) – diff. coefficient external</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="DDR_intface.assemble_b_J">
<span class="sig-prename descclassname"><span class="pre">DDR_intface.</span></span><span class="sig-name descname"><span class="pre">assemble_b_J</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">J_datum</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma_in</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma_ex</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#DDR_intface.assemble_b_J" title="Permalink to this definition"></a></dt>
<dd><p>Assembles rhs B_J (jump at interface)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mesh</strong> (<em>mema.mesh2D</em>) – mesh</p></li>
<li><p><strong>J_datum</strong> (<em>lambda</em>) – jump value</p></li>
<li><p><strong>sigma_in</strong> (<em>float</em>) – diff. coefficient internal</p></li>
<li><p><strong>sigma_ex</strong> (<em>float</em>) – diff. coefficient external</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="DDR_intface.calc_L0_error">
<span class="sig-prename descclassname"><span class="pre">DDR_intface.</span></span><span class="sig-name descname"><span class="pre">calc_L0_error</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">u</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ref_sol</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#DDR_intface.calc_L0_error" title="Permalink to this definition"></a></dt>
<dd><p>Calculate L0 error
:type mesh: 
:param mesh: mesh
:type mesh: mema.mesh2D
:type u: 
:param u: numeric solution
:type u: np.array
:type ref_sol: 
:param ref_sol: reference solution (wrapper to be called onto (mesh, dof))
:type ref_sol: lambda</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="DDR_intface.calc_L2_error">
<span class="sig-prename descclassname"><span class="pre">DDR_intface.</span></span><span class="sig-name descname"><span class="pre">calc_L2_error</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">u</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ref_sol</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#DDR_intface.calc_L2_error" title="Permalink to this definition"></a></dt>
<dd><p>Calculate L2 error
:type mesh: 
:param mesh: mesh
:type mesh: mema.mesh2D
:type u: 
:param u: numeric solution
:type u: np.array
:type ref_sol: 
:param ref_sol: reference solution (wrapper to be called onto (mesh, dof))
:type ref_sol: lambda</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="DDR_intface.calc_energy_error">
<span class="sig-prename descclassname"><span class="pre">DDR_intface.</span></span><span class="sig-name descname"><span class="pre">calc_energy_error</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">u</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ref_sol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N_gamma</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#DDR_intface.calc_energy_error" title="Permalink to this definition"></a></dt>
<dd><p>Calculate energy error
:type mesh: 
:param mesh: mesh
:type mesh: mema.mesh2D
:type u: 
:param u: numeric solution
:type u: np.array
:type ref_sol: 
:param ref_sol: reference solution as function of mesh and dof
:type ref_sol: lambda
:type G: 
:param G: grad.grad matrix
:type G: np.array
:type N_gamma: 
:param N_gamma: interface jump penalization matrix
:type N_gamma: np.array
:type S: 
:param S: stabilization matrix
:type S: np.array</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="DDR_intface.calc_r2_prod_integ">
<span class="sig-prename descclassname"><span class="pre">DDR_intface.</span></span><span class="sig-name descname"><span class="pre">calc_r2_prod_integ</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v1A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v1B</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v2A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v2B</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#DDR_intface.calc_r2_prod_integ" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the integral over the [0,1] of the product between 2 affine functions assigned through their
values at vertices 0 and 1 (first values at 0 of f1 and f2 an then values at 1)
(a bit redeundant now that there is quadrature)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>v1A</strong> (<em>float</em>) – value of p1 function 1 at node A (0)</p></li>
<li><p><strong>v1B</strong> (<em>float</em>) – value of p1 function 1 at node B (1)</p></li>
<li><p><strong>v2A</strong> (<em>float</em>) – value of p1 function 2 at node A (0)</p></li>
<li><p><strong>v2B</strong> (<em>float</em>) – value of p1 function 2 at node A (1)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="DDR_intface.calc_t_maxwell">
<span class="sig-prename descclassname"><span class="pre">DDR_intface.</span></span><span class="sig-name descname"><span class="pre">calc_t_maxwell</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">intface</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">u</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps_in</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps_ext</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#DDR_intface.calc_t_maxwell" title="Permalink to this definition"></a></dt>
<dd><p>Calculates Maxwell tension from solution of DDRIN
:type mesh: 
:param mesh: mesh
:type mesh: mesh2D
:type intface: 
:param intface: interface
:type intface: disk_intface
:type u: 
:param u: node_wise potential
:type eps_in: 
:param eps_in: internal permittivity
:type eps_ext: 
:param eps_ext: external permittivity</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="DDR_intface.count_dof">
<span class="sig-prename descclassname"><span class="pre">DDR_intface.</span></span><span class="sig-name descname"><span class="pre">count_dof</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#DDR_intface.count_dof" title="Permalink to this definition"></a></dt>
<dd><p>Total DOF number</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="DDR_intface.disc_grad">
<span class="sig-prename descclassname"><span class="pre">DDR_intface.</span></span><span class="sig-name descname"><span class="pre">disc_grad</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iel</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#DDR_intface.disc_grad" title="Permalink to this definition"></a></dt>
<dd><p>Computes the discrete gradient matrix of an element,
such that GRAD*[nodal values] returns the gradient of the local
distribution of dofs [nodal values], i.e.:
j-th column is discrete gradient of basis function of node j</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mesh</strong> (<em>mema.mesh2D</em>) – mesh</p></li>
<li><p><strong>iel</strong> (<em>int</em>) – element index</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="DDR_intface.glob_idx">
<span class="sig-prename descclassname"><span class="pre">DDR_intface.</span></span><span class="sig-name descname"><span class="pre">glob_idx</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iel</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ino</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#DDR_intface.glob_idx" title="Permalink to this definition"></a></dt>
<dd><p>Local DOF to global DOF connectivity for solver DDR_interfaces
Convention for dof ordering: [internal unknowns, intface unknowns side in, intface unknowns side ex]</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mesh</strong> (<em>mema.mesh2D</em>) – mesh</p></li>
<li><p><strong>iel</strong> (<em>int</em>) – element index</p></li>
<li><p><strong>ino</strong> (<em>int</em>) – local node index</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="DDR_intface.impose_bc">
<span class="sig-prename descclassname"><span class="pre">DDR_intface.</span></span><span class="sig-name descname"><span class="pre">impose_bc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ref_sol</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#DDR_intface.impose_bc" title="Permalink to this definition"></a></dt>
<dd><p>Modifies the system to impose boundary conditions</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mesh</strong> (<em>mema.mesh2D</em>) – mesh</p></li>
<li><p><strong>A</strong> (<em>np.array</em>) – lhs matrix</p></li>
<li><p><strong>b</strong> (<em>np.array</em>) – rhs array</p></li>
<li><p><strong>ref_sol</strong> (<em>lambda</em>) – reference solution</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="DDR_intface.p1_rec_matrix">
<span class="sig-prename descclassname"><span class="pre">DDR_intface.</span></span><span class="sig-name descname"><span class="pre">p1_rec_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iel</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#DDR_intface.p1_rec_matrix" title="Permalink to this definition"></a></dt>
<dd><p>Returns the P1 reconstruction matrix such that [p1 rec nodal values] = R*[nodal_values]</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mesh</strong> (<em>mesh.mesh2D</em>) – mesh</p></li>
<li><p><strong>iel</strong> (<em>int</em>) – element index</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>np.array</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="DDR_intface.pretty_visualize">
<span class="sig-prename descclassname"><span class="pre">DDR_intface.</span></span><span class="sig-name descname"><span class="pre">pretty_visualize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">u</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fig</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cmap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'magma'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#DDR_intface.pretty_visualize" title="Permalink to this definition"></a></dt>
<dd><p>Visualize numeric solution</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mesh</strong> (<em>mema.mesh2D</em>) – mesh</p></li>
<li><p><strong>u</strong> (<em>np.array</em>) – numeric solution</p></li>
<li><p><strong>fig</strong> – figure</p></li>
<li><p><strong>ax</strong> – figure</p></li>
<li><p><strong>cmap</strong> – colormap</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="DDR_intface.pretty_visualize_gradient">
<span class="sig-prename descclassname"><span class="pre">DDR_intface.</span></span><span class="sig-name descname"><span class="pre">pretty_visualize_gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">u</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fig</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cmap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'magma'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#DDR_intface.pretty_visualize_gradient" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="DDR_intface.reference_solution">
<span class="sig-prename descclassname"><span class="pre">DDR_intface.</span></span><span class="sig-name descname"><span class="pre">reference_solution</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dof</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rho</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ref_sol_in</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ref_sol_ex</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t_dep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#DDR_intface.reference_solution" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="DDR_intface.solve">
<span class="sig-prename descclassname"><span class="pre">DDR_intface.</span></span><span class="sig-name descname"><span class="pre">solve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ref_sol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma_in</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma_ex</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">J_datum</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#DDR_intface.solve" title="Permalink to this definition"></a></dt>
<dd><p>Solves an elliptic interface problem, given mesh and data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mesh</strong> (<em>mema.mesh2D</em>) – mesh</p></li>
<li><p><strong>ref_sol</strong> (<em>lambda</em>) – reference solution (or boundary data)</p></li>
<li><p><strong>sigma_in</strong> (<em>float</em>) – diffusion coefficient internal</p></li>
<li><p><strong>sigma_ex</strong> (<em>float</em>) – diffusion coefficient external</p></li>
<li><p><strong>eta</strong> (<em>float</em>) – user-dependent parameter for jump conditoins “a la nitsche”</p></li>
<li><p><strong>J_datum</strong> (<em>lambda</em>) – interface jump</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>solution u
np.array : global system matrix A
np.array : global system r.h.s. b
np.array : block matrix G (grad*grad)
np.array : block matrix M_gamma (interface jump of gradient)
np.array : block matrix N_gamma (interface jump)
np.array : block r.h.s. b_j (interface jump)</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.array</p>
</dd>
</dl>
</dd></dl>

</section>
</section>
<section id="bibliography">
<h1>Bibliography<a class="headerlink" href="#bibliography" title="Permalink to this heading"></a></h1>
<div class="docutils container" id="id3">
<dl class="citation">
<dt class="label" id="id235"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>D. A. Di Pietro and J. Droniou. <em>The Hybrid High-Order method for polytopal meshes</em>. Number 19 in Modeling, Simulation and Application. Springer International Publishing, 2020. <a class="reference external" href="https://doi.org/10.1007/978-3-030-37203-3">doi:10.1007/978-3-030-37203-3</a>.</p>
</dd>
<dt class="label" id="id237"><span class="brackets"><a class="fn-backref" href="#id2">2</a></span></dt>
<dd><p>Daniele A. Di Pietro and Jérôme Droniou. An arbitrary-order discrete de Rham complex on polyhedral meshes: Exactness, Poincaré inequalities, and consistency. <em>Found. Comput. Math.</em>, 23:85–164, 2023. <a class="reference external" href="https://doi.org/10.1007/s10208-021-09542-8">doi:10.1007/s10208-021-09542-8</a>.</p>
</dd>
</dl>
</div>
</section>
<section id="indices-and-tables">
<h1>Indices and tables<a class="headerlink" href="#indices-and-tables" title="Permalink to this heading"></a></h1>
<ul class="simple">
<li><p><a class="reference internal" href="genindex.html"><span class="std std-ref">Index</span></a></p></li>
<li><p><a class="reference internal" href="py-modindex.html"><span class="std std-ref">Module Index</span></a></p></li>
<li><p><a class="reference internal" href="search.html"><span class="std std-ref">Search Page</span></a></p></li>
</ul>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, aurelio_spadotto.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>
